#!/usr/bin/env bash
#
# wgc - Manage multiple WireGuard VPNs using Linux network namespaces.
# Copyright (C) 2025 Marco Coletti <colemarc@gmail.com>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

[[ $UID == 0 ]] || exec sudo "$0" "$@"

show_usage() {
  cat <<EOF
Usage: $THIS [-c|--cfgdir config_dir] [start <vpn>|stop <vpn>|status <vpn>|active|list|exec <vpn> <command>]

If omitted, config_dir defaults to /etc/wireguard

<vpn> should match the config file name config_dir/<vpn>.conf

Commands:
  start  - Start the VPN connection
  stop   - Stop the VPN connection
  status - Show VPN connection status
  active - Show active VPN namespaces
  list   - List config files in config_dir
  exec   - Execute a command in the VPN namespace
           Example: $THIS <vpn> exec curl ifconfig.me

To enable bash completion: $THIS completion
EOF
}

check_dependencies() {
  local missing=()
  for cmd in ip wg; do
    command -v $cmd >/dev/null || missing+=($cmd)
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "$N ERROR: Missing required commands: ${missing[*]}"
    echo "Install with: apt install wireguard-tools iproute2"
    return 1
  fi
}

list_config_files() {
  local f
  printf "%-12s %-18s %-18s %s\n" "Name" "Address" "AllowedIPs" "Endpoint"
  printf "%-12s %-18s %-18s %s\n" "----" "-------" "----------" "--------"
  for f in "$CFGDIR"/*.conf; do
    [[ "$f" == "$CFGDIR/*.conf" ]] && return 0
    f=${f##*/}; f=${f%.*}
    [[ $f =~ wg[0-9]+ ]] && continue # exclude wg0, wg1, wg2 ...
    parse_config_file "$f" || return 1
    printf "%-12s %-18s %-18s %s\n" "$f" "$Address" "$AllowedIPs" "$Endpoint"
  done
}

parse_config_file() {
  local CONFIG_FILE="$CFGDIR/$1.conf"
  [[ -f "$CONFIG_FILE" ]] || { echo "$N Config file not found: $CONFIG_FILE"; return 1; }
  [[ -r "$CONFIG_FILE" ]] || { echo "$N Can't read file: $CONFIG_FILE"; return 1; }
  local line n=0 section key value
  WARNINGS=; BADSECTION=
  while read -r line || [[ -n "$line" ]]; do # also read last line if \n is missing
      ((n++))
      line="${line%%#*}" # Remove comments
      if [[ "$line" =~ ^[[:space:]]*(\[[A-Za-z0-9]+\])[[:space:]]*$ ]]; then
        section="${BASH_REMATCH[1]}" # Track section
        continue
      fi
      # Skip lines in bad sections (even before all sections)
      [[ "$section" == "$BADSECTION" ]] && continue
      # Parse key=value with flexible spacing, preserving = in value
      if [[ "$line" =~ ^[[:space:]]*([A-Za-z0-9]+)[[:space:]]*=[[:space:]]*(.*[^[:space:]]) ]]; then
        key="${BASH_REMATCH[1]}"   # key without spaces
        value="${BASH_REMATCH[2]}" # value trimmed, with = preserved
      else # Not a key=value line
        if [[ "$line" =~ [^[:space:]] ]]; then # also not empty
          WARNINGS+="\nMalformed line $n: '${line:0:50}...'"
        fi
        continue
      fi
      # Get values according to section/key
      process_config_line $n "$key" "$value" "$section"
  done < "$CONFIG_FILE"
  [[ "$WARNINGS" ]] && echo -e "$N Warnings for $CONFIG_FILE:$WARNINGS" >&2
  local k
  for k in Address PrivateKey PublicKey Endpoint AllowedIPs; do
    [[ ${!k} ]] || { echo "$N ERROR: Missing required key '$k' in file $CONFIG_FILE" >&2; return 1; }
  done
}

process_config_line() {
  local n="$1"
  local key="$2"
  local value="$3"
  local section="$4"

  case "$section" in
    "[Interface]")
      case "$key" in
        Address) Address=$(extract_ipv4 "$value") ;;
        DNS) DNS=$(extract_all_ipv4 "$value") ;;
        MTU) MTU="$value" ;;
        PrivateKey) PrivateKey="$value" ;;
        *) WARNINGS+="\nUnknown key '$key' in section '$section' at line $n" ;;
      esac
      ;;
    "[Peer]")
      case "$key" in
        AllowedIPs) AllowedIPs=$(extract_ipv4 "$value") ;;
        Endpoint) Endpoint="$value" ;;
        PersistentKeepalive) PersistentKeepalive="$value" ;;
        PresharedKey) PresharedKey="$value" ;;
        PublicKey) PublicKey="$value" ;;
        *) WARNINGS+="\nUnknown key '$key' in section '$section' at line $n" ;;
      esac
      ;;
    *)
      BADSECTION=$section
      WARNINGS+="\nUnknown section '$section' at line $((n-1))"
      ;;
  esac
}

extract_ipv4() {
  local input="$1"
  local regex='([0-9]{1,3}\.){3}[0-9]{1,3}(/[0-9]+)?'
  if [[ $input =~ $regex ]]; then
    echo "${BASH_REMATCH[0]}"
  fi
}

extract_all_ipv4() {
  local input="$1"
  local result=""
  local regex='([0-9]{1,3}\.){3}[0-9]{1,3}'
  while [[ $input =~ $regex ]]; do
    result="$result${BASH_REMATCH[0]} "
    # Remove found match and go on
    input="${input/"${BASH_REMATCH[0]}"/}"
  done
  # Remove final space
  echo "${result% }"
}

is_connected() {
  ip netns exec $NAMESPACE ip address show $DEV &>/dev/null
}

show_status() {
  if is_connected; then
    echo "$Y $DEV VPN is CONNECTED"
    echo
    ip netns exec $NAMESPACE wg show $DEV
    echo
    echo "Interface details:"
    ip netns exec $NAMESPACE ip -c addr show $DEV
    echo
    echo "Routes:"
    ip netns exec $NAMESPACE ip -c route show
    echo
    echo "DNS:"
    grep -E --color '([0-9]{1,3}\.){3}[0-9]{1,3}' \
      /etc/netns/$NAMESPACE/resolv.conf 2>/dev/null || echo "  (none)"
    echo
    echo "Processes running in namespace $NAMESPACE:"
    pids=$(ip netns pids $NAMESPACE 2>/dev/null)
    [[ $pids ]] && ps -fp $pids || echo "  (none)"
  else
    echo "$N $DEV VPN is DISCONNECTED"
    return 0
  fi
}

show_active_vpns() {
  local ns x net found=false
  while read -r ns x; do
    found=true
    if ip netns exec $ns wg show $ns &>/dev/null; then
      read -r ns x net < <(ip netns exec $ns ip -br -c address show $ns 2>/dev/null)
      echo $ns $net
    fi
  done < <(ip netns list 2>/dev/null) || true
  $found || echo "$N No active VPN namespaces"
}

kill_processes() {
  local pids=$1
  echo -e "Terminating processes:\n$(ps -fp $pids)"
  kill $pids &>/dev/null || true
  # paint increasing bar for timeout
  local h d timeout=10 # seconds
  eval printf -v d "$'\u2591'%.0s" {1..$((timeout*2))} # timeout*2 LIGHT SHADEs in d
  echo -ne "\033[?25l" # hide cursor
  while [[ "$pids" && "$d" ]]; do
    sleep 0.5
    pids=$(ip netns pids $NAMESPACE 2>/dev/null)
    d=${d%$'\u2591'} # remove one LIGHT SHADE
    echo -ne "\r$h$d" # paint the bar over itself
    h+=$'\u2588' # append a FULL BLOCK
  done
  echo -ne "\r\033[K\033[?25h" # delete bar and restore cursor
  if [[ -z "$d" ]]; then # timeout
    echo "Forcibly terminating processes (SIGKILL)"
    kill -9 $pids &>/dev/null || true
    sleep 0.1
    # check again
    pids=$(ip netns pids $NAMESPACE 2>/dev/null)
    [[ "$pids" ]] && echo "$N Warning: processes still running: $pids"
  fi
}

stop_vpn() {
  local force=$1
  is_connected || {
    echo "$N $DEV is already disconnected"
    return 0
  }
  local pids=$(ip netns pids $NAMESPACE 2>/dev/null)
  if [[ "$pids" ]]; then
    if [[ "$force" == force ]]; then
      kill_processes "$pids"
    else
      echo -e "$N Processes running in namespace $NAMESPACE:\n$(ps -fp $pids)\n"
      echo "Force stop (killing processes) with: $THIS stop $DEV force"
      return
    fi
  fi
  # ip netns del removes all interfaces within the namespace automatically
  ip netns del $NAMESPACE &>/dev/null || true
  rm -rf /etc/netns/$NAMESPACE &>/dev/null || true
  echo "$Y $DEV is now disconnected"
}

exec_in_namespace() {
  [[ $# -eq 0 ]] && { echo "$N ERROR: No command specified"; show_usage; return 1; }
  is_connected || {
    echo "$N ERROR: $DEV VPN is not connected. Start it first with: $THIS start $DEV"
    return 1
  }
  exec ip netns exec $NAMESPACE sudo -u "${SUDO_USER:-$USER}" "$@"
}

enable_completion() {
  local completion_file="/etc/bash_completion.d/$THIS"

  cat > "$completion_file" << 'EOF'
_wgc_completion() {
  local cur prev commands
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  # Main commands
  commands="start stop status active list exec"

  # Complete the first arg with main commands
  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
    return 0
  fi

  # Complete the second arg depending on command
  if [[ $COMP_CWORD -eq 2 ]]; then
    local vpns
    case "$prev" in
      star|start)
        # VPN config file list
        local f
        vpns=$(
          for f in $(sudo find /etc/wireguard -maxdepth 1 -name "*.conf" -type f 2>/dev/null); do
            f=${f##*/}; f=${f%.*}
            [[ $f =~ wg[0-9]+ ]] && continue # exclude wg0, wg1, wg2 ...
            echo "$f"
          done )
        COMPREPLY=( $(compgen -W "$vpns" -- "$cur") )
        ;;
      sto|stop|stat|statu|status|e|ex|exe|exec)
        # Active VPNs (namespaces) list
        local ns x
        vpns=$(
          while read -r ns x; do
            sudo ip netns exec "$ns" wg show "$ns" &>/dev/null && echo "$ns"
          done < <(sudo ip netns list 2>/dev/null) )
        COMPREPLY=( $(compgen -W "$vpns" -- "$cur") )
        ;;
    esac
    return 0
  fi

  # For exec, after VPN name do complete with system commmands
	if [[ $COMP_CWORD -gt 2 ]]; then
		case "${COMP_WORDS[1]}" in
			e|ex|exe|exec)
				if declare -F _command_offset &>/dev/null; then
					# Use advanced completion if available
					_command_offset 3
				else
					# Fallback to basic completion
					if [[ $COMP_CWORD -eq 3 ]]; then
						COMPREPLY=( $(compgen -c -- "$cur") )
					else
						compopt -o default
						COMPREPLY=()
					fi
				fi
				return 0
				;;
		esac
	fi
}

complete -F _wgc_completion wgc
EOF

  chmod 644 "$completion_file"

  cat << EOF
$Y Bash completion installed to $completion_file

To activate completion in current shell:
  source $completion_file

Completion will be automatically available in new shell sessions.

To avoid sudo password prompt:
  sudo visudo -f /etc/sudoers.d/wgc-completion
  Then add:
  %sudo ALL=(ALL) NOPASSWD: /usr/bin/find /etc/wireguard/ -maxdepth 1 -name *.conf -type f
  %sudo ALL=(ALL) NOPASSWD: /usr/sbin/ip netns list
  %sudo ALL=(ALL) NOPASSWD: /usr/sbin/ip netns exec * wg show *
EOF
}

clean() {
  # If interface is not yet in namespace, delete it.
  ip link del $DEV &>/dev/null || true
  # Clean up any existing namespace and interface silently
  ip netns del $NAMESPACE &>/dev/null || true
  rm -rf /etc/netns/$NAMESPACE &>/dev/null || true
  # Note: Processes that were in the deleted namespace lose network connectivity
  # but continue running.
}

show_config() {
  for k in Address PrivateKey PublicKey PresharedKey Endpoint AllowedIPs PersistentKeepalive; do
    echo "$k=${!k}"
  done
  echo
}

validate_ipv4() {
  local ip=$1
  ip -4 rule add to "$ip" &>/dev/null || return 1
  ip -4 rule del to "$ip" &>/dev/null || true
}

start_vpn() {

  # get parameters from config file named $DEV
  parse_config_file $DEV || return 1

  if ip netns exec $NAMESPACE ip -c address show $DEV 2>/dev/null; then
    echo "$N $DEV is already connected"
    echo "  To reconnect, first stop it: $THIS stop $DEV"
    return 1
  fi

  clean # Clean slate - removes namespace, interface, DNS config

  # Create WireGuard interface
  ip link add dev $DEV type wireguard || {
    echo "$N ERROR: Failed to create WireGuard interface '$DEV'" >&2
    return 1
  }

  # Configure WireGuard
  local wgcmd='wg set $DEV'
  wgcmd+=' private-key <(echo "$PrivateKey")'
  wgcmd+=' peer "$PublicKey"'
  wgcmd+=' allowed-ips "$AllowedIPs"'
  wgcmd+=' endpoint "$Endpoint"'
  [[ $PresharedKey ]] && wgcmd+=' preshared-key <(echo "$PresharedKey")'
  [[ $PersistentKeepalive ]] && wgcmd+=' persistent-keepalive "$PersistentKeepalive"'
  eval $wgcmd || {
    echo "$N ERROR: Failed to configure WireGuard interface '$DEV' using command:" >&2
    wgcmd=${wgcmd/\$PrivateKey/<HIDDEN>}
    eval $'cat <<EOF\n'$wgcmd$'\nEOF'
    clean
    return 1
  }

  # Create and configure namespace
  ip netns add $NAMESPACE || {
    echo "$N ERROR: Failed to create namespace '$NAMESPACE'" >&2
    clean
    return 1
  }
  ip link set $DEV netns $NAMESPACE || {
    echo "$N ERROR: Failed to move interface '$DEV' to namespace '$NAMESPACE'" >&2
    clean
    return 1
  }
  ip netns exec $NAMESPACE ip link set lo up
  ip netns exec $NAMESPACE ip addr add "$Address" dev $DEV || {
    echo "$N ERROR: Failed to configure address '$Address' for interface '$DEV'" >&2
    clean
    return 1
  }
  [[ $MTU ]] && ip netns exec $NAMESPACE ip link set $DEV mtu $MTU
  ip netns exec $NAMESPACE ip link set $DEV up
  ip netns exec $NAMESPACE ip route add default dev $DEV

  # Configure DNS
  mkdir -p /etc/netns/$NAMESPACE
  for dns in $DNS; do
    if validate_ipv4 "$dns"; then
      echo "nameserver $dns"
    else
      echo "$N Warning: Skipping invalid DNS server '$dns'" >&2
    fi
  done > /etc/netns/$NAMESPACE/resolv.conf
  # Check if we have at least one DNS server
  if [[ ! -s /etc/netns/$NAMESPACE/resolv.conf ]]; then
    echo "$N Warning: No valid DNS servers configured" >&2
  fi

  echo "$Y VPN connected successfully"
  echo
  ip netns exec $NAMESPACE wg show $DEV
  echo
  echo "Network namespace: $NAMESPACE"
  echo
  echo "Interface details:"
  ip netns exec $NAMESPACE ip -c addr show $DEV
  echo
  echo "Routes:"
  ip netns exec $NAMESPACE ip -c route show
  echo
  echo "DNS:"
  grep -E --color '([0-9]{1,3}\.){3}[0-9]{1,3}' \
    /etc/netns/$NAMESPACE/resolv.conf 2>/dev/null || echo "  (none)"
  echo
  echo "To run commands in the VPN namespace:"
  echo "  $THIS exec $NAMESPACE <command>"
  echo "  Example: $THIS exec $NAMESPACE curl ifconfig.me"
}

validate_vpn_name() {
  case "$CMD" in
    a*|l*|completion)
      [[ -z "$DEV" ]] || { show_usage; return 1; }
      ;;
    *)
      [[ $DEV =~ ^[a-zA-Z0-9_-]+$ ]] || {
        echo "$N ERROR: Invalid VPN name '$DEV'. Use only alphanumeric, dash, underscore" >&2
        return 1
      }
      ;;
  esac
}

# -----------------------------------------------------------------------------
set +e +x
THIS=${0##*/}
Y=$'\e[01;32m\u2713\e[m' # green CHECK MARK
N=$'\e[01;31m\u2717\e[m' # red BALLOT X
CFGDIR=/etc/wireguard

check_dependencies || exit 1

LONGOPTIONS=
LONGOPTIONS+=cfgdir

declare -r LONGOPTIONS

OPTS="$(getopt -o c: --longoptions $LONGOPTIONS -- "$@")" || { show_usage && exit 1; }
eval set -- "$OPTS"
unset OPTS

while [[ -v 1 ]]; do
  case "$1" in
    -c | --cfgdir)
      CFGDIR=$2
      shift 2
      ;;
    --)
      shift
      break
      ;;
  esac
done

declare -r CFGDIR

CMD=$1
DEV=$2
NAMESPACE=$DEV

validate_vpn_name || exit 1

case "$CMD" in
  star|start)
    start_vpn
    ;;
  sto|stop)
    stop_vpn $3 # $3 can be "force"
    ;;
  stat|statu|status)
    show_status
    ;;
  a|ac|act|acti|activ|active)
    show_active_vpns
    ;;
  l|li|lis|list)
    list_config_files
    ;;
  e|ex|exe|exec)
    shift; shift
    exec_in_namespace "$@"
    ;;
  completion)
    enable_completion
    ;;
  *)
    show_usage
    ;;
esac
